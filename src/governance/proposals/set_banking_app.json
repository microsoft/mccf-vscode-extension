{"actions":[{"name":"set_js_app","args":{"bundle":{"metadata":{"endpoints":{"/account/{user_id}/{account_name}":{"put":{"js_module":"endpoints/banking.js","js_function":"createAccount","forwarding_required":"always","authn_policies":["member_cert"],"mode":"readwrite","openapi":{"responses":{"200":{"description":"Ok"}},"security":[],"parameters":[]}}},"/deposit/{user_id}/{account_name}":{"post":{"js_module":"endpoints/banking.js","js_function":"deposit","forwarding_required":"always","authn_policies":["member_cert"],"mode":"readwrite","openapi":{"responses":{"200":{"description":"Ok"}},"security":[],"parameters":[],"requestBody":{"required":true,"content":{"application/json":{"schema":{"properties":{"value":{"type":"number"}},"type":"object"}}}}}}},"/balance/{account_name}":{"get":{"js_module":"endpoints/banking.js","js_function":"balance","forwarding_required":"sometimes","authn_policies":["user_cert"],"mode":"readonly","openapi":{"responses":{"200":{"description":"Ok"}},"security":[],"parameters":[]}}},"/transfer/{account_name}":{"post":{"js_module":"endpoints/banking.js","js_function":"transfer","forwarding_required":"always","authn_policies":["user_cert"],"mode":"readwrite","openapi":{"responses":{"200":{"description":"Ok"}},"security":[],"parameters":[],"requestBody":{"required":true,"content":{"application/json":{"schema":{"properties":{"value":{"type":"number"},"user_id_to":{"type":"string"},"account_name_to":{"type":"string"}},"type":"object"}}}}}}}}},"modules":[{"name":"endpoints/all.js","module":"export { balance, createAccount, deposit, transfer } from './banking.js';\n"},{"name":"endpoints/banking.js","module":"import { typedKv } from '../node_modules/@microsoft/ccf-app/kv.js';\nimport { uint32, string } from '../node_modules/@microsoft/ccf-app/converters.js';\nimport '../node_modules/@microsoft/ccf-app/consensus.js';\nimport '../node_modules/@microsoft/ccf-app/historical.js';\nimport '../node_modules/@microsoft/ccf-app/endpoints.js';\n\nfunction validateAccountName(accountName) {\n    return true;\n}\nfunction createAccount(request) {\n    const userId = request.params.user_id;\n    const accountToBalance = typedKv(`user_accounts:${userId}`, string, uint32);\n    const accountName = request.params.account_name;\n    if (!validateAccountName(request.params.account_name)) ;\n    if (accountToBalance.has(accountName)) {\n        return { body: \"OK\" };\n    }\n    accountToBalance.set(accountName, 0);\n    console.log('Create Account Completed');\n    return { body: \"OK\" };\n}\nfunction deposit(request) {\n    const body = request.body.json();\n    const userId = request.params.user_id;\n    const accountName = request.params.account_name;\n    const value = parseInt(body.value);\n    const accountToBalance = typedKv(`user_accounts:${userId}`, string, uint32);\n    if (!accountToBalance.has(accountName)) {\n        return { statusCode: 404 };\n    }\n    accountToBalance.set(accountName, accountToBalance.get(accountName) + value);\n    console.log('Deposit Completed');\n    return { body: \"OK\" };\n}\nfunction balance(request) {\n    const caller = request.caller;\n    const userId = caller.id;\n    const accountName = request.params.account_name;\n    const accountToBalance = typedKv(`user_accounts:${userId}`, string, uint32);\n    if (!accountToBalance.has(accountName)) {\n        return { statusCode: 404 };\n    }\n    return { body: { balance: accountToBalance.get(accountName) } };\n}\nfunction transfer(request) {\n    const body = request.body.json();\n    const caller = request.caller;\n    const userId = caller.id;\n    const accountName = request.params.account_name;\n    const value = parseInt(body.value);\n    const accountNameTo = body.account_name_to;\n    const userIdTo = body.user_id_to;\n    const accountToBalance = typedKv(`user_accounts:${userId}`, string, uint32);\n    if (!accountToBalance.has(accountName)) {\n        return { statusCode: 404 };\n    }\n    const balance = accountToBalance.get(accountName);\n    if (value > balance) {\n        return { statusCode: 400, body: \"Balance is not enough\" };\n    }\n    accountToBalance.set(accountName, balance - value);\n    const accountToBalanceTo = typedKv(`user_accounts:${userIdTo}`, string, uint32);\n    if (!accountToBalanceTo.has(accountNameTo)) {\n        return { statusCode: 404 };\n    }\n    accountToBalanceTo.set(accountNameTo, accountToBalanceTo.get(accountNameTo) + value);\n    console.log('Transfer Completed');\n    return { body: \"OK\" };\n}\n\nexport { balance, createAccount, deposit, transfer };\n"},{"name":"node_modules/@microsoft/ccf-app/consensus.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n/**\n * @inheritDoc CCFConsensus.getLastCommittedTxId;\n */\nccf.consensus.getLastCommittedTxId.bind(ccf.consensus);\n/**\n * @inheritDoc CCFConsensus.getStatusForTxId;\n */\nccf.consensus.getStatusForTxId.bind(ccf.consensus);\n/**\n * @inheritDoc CCFConsensus.getViewForSeqno;\n */\nccf.consensus.getViewForSeqno.bind(ccf.consensus);\n"},{"name":"node_modules/@microsoft/ccf-app/converters.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\nclass Uint32Converter {\n    encode(val) {\n        if (val < 0 || val > 4294967295) {\n            throw new RangeError(\"value is not within uint32 range\");\n        }\n        const buf = new ArrayBuffer(4);\n        new DataView(buf).setUint32(0, val, true);\n        return buf;\n    }\n    decode(buf) {\n        return new DataView(buf).getUint32(0, true);\n    }\n}\nclass StringConverter {\n    encode(val) {\n        return ccf.strToBuf(val);\n    }\n    decode(buf) {\n        return ccf.bufToStr(buf);\n    }\n}\n/**\n * Converter for `number` values, encoded as `uint32`.\n *\n * Example:\n * ```\n * const buf = ccfapp.uint32.encode(50000); // ArrayBuffer of size 4\n * const val = ccfapp.uint32.decode(buf);   // number\n * ```\n */\nconst uint32 = new Uint32Converter();\n/**\n * Converter for `string` values, encoded as UTF-8.\n *\n * Example:\n * ```\n * const buf = ccfapp.string.encode('my-string'); // ArrayBuffer\n * const val = ccfapp.string.decode(buf);         // string\n * ```\n */\nconst string = new StringConverter();\n\nexport { string, uint32 };\n"},{"name":"node_modules/@microsoft/ccf-app/endpoints.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n/**\n * @inheritDoc CCF.rpc.setApplyWrites\n */\nccf.rpc.setApplyWrites.bind(ccf.rpc);\n/**\n * @inheritDoc CCF.rpc.setClaimsDigest\n */\nccf.rpc.setClaimsDigest.bind(ccf.rpc);\n"},{"name":"node_modules/@microsoft/ccf-app/global.js","module":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the Apache 2.0 License.\n/**\n * This module describes the global {@linkcode ccf} variable.\n * Direct access of this module or the {@linkcode ccf} variable is\n * typically not needed as all of its functionality is exposed\n * via other, often more high-level, modules.\n *\n * Accessing the {@linkcode ccf} global in a type-safe way is done\n * as follows:\n *\n * ```\n * import { ccf } from '@microsoft/ccf-app/global.js';\n * ```\n *\n * @module\n */\n// The global ccf variable and associated types are exported\n// as a regular module instead of using an ambient namespace\n// in a .d.ts definition file.\n// This avoids polluting the global namespace.\nconst ccf = globalThis.ccf;\n\nexport { ccf };\n"},{"name":"node_modules/@microsoft/ccf-app/historical.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n/**\n * @inheritDoc global!CCF.historicalState\n */\nccf.historicalState;\n/**\n * @inheritDoc CCFHistorical.getStateRange\n */\nccf.historical.getStateRange.bind(ccf.historical);\n/**\n * @inheritDoc CCFHistorical.dropCachedStates\n */\nccf.historical.dropCachedStates.bind(ccf.historical);\n"},{"name":"node_modules/@microsoft/ccf-app/kv.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\nclass TypedKvMap {\n    constructor(kv, kt, vt) {\n        this.kv = kv;\n        this.kt = kt;\n        this.vt = vt;\n    }\n    has(key) {\n        return this.kv.has(this.kt.encode(key));\n    }\n    get(key) {\n        const v = this.kv.get(this.kt.encode(key));\n        return v === undefined ? undefined : this.vt.decode(v);\n    }\n    set(key, value) {\n        this.kv.set(this.kt.encode(key), this.vt.encode(value));\n        return this;\n    }\n    delete(key) {\n        this.kv.delete(this.kt.encode(key));\n    }\n    clear() {\n        this.kv.clear();\n    }\n    forEach(callback) {\n        let kt = this.kt;\n        let vt = this.vt;\n        let typedMap = this;\n        this.kv.forEach(function (raw_v, raw_k, table) {\n            callback(vt.decode(raw_v), kt.decode(raw_k), typedMap);\n        });\n    }\n    get size() {\n        return this.kv.size;\n    }\n}\n/**\n * Returns a typed view of a map in the Key-Value Store,\n * where keys and values are automatically converted\n * to and from ``ArrayBuffer`` based on the given key\n * and value converters.\n *\n * See the {@linkcode converters} module for available converters.\n *\n * @param nameOrMap Either the map name in the Key-Value Store,\n *    or a ``KvMap`` object.\n * @param kt The converter to use for map keys.\n * @param vt The converter to use for map values.\n */\nfunction typedKv(nameOrMap, kt, vt) {\n    const kvMap = typeof nameOrMap === \"string\" ? ccf.kv[nameOrMap] : nameOrMap;\n    return new TypedKvMap(kvMap, kt, vt);\n}\n/**\n * @inheritDoc global!CCF.kv\n */\nccf.kv;\n\nexport { TypedKvMap, typedKv };\n"}]}}}]}
